<xml xmlns="https://developers.google.com/blockly/xml"><variables></variables><block type="pxt-on-start" id="iAw-0p)*(Ho0$lb.-f?h" x="20" y="20"><statement name="HANDLER"><block type="typescript_statement" id="H_D|-mxllgbHfpt#SJc}"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace ZETag_R2a {" line1="    let rxBuffer: Buffer = Buffer.create(0)" line2="    let txBuffer = pins.createBuffer(1);" line3="" line4="    /**" line5="     * Binary data transmission over UART" line6="     * @param TX_data: 8bit data" line7="    */" line8="    function UART_BIN_TX(txByte: number): void {" line9="        txBuffer.setUint8(0, txByte);" line10="        serial.writeBuffer(txBuffer)" line11="    }" line12="" line13="    /**" line14="     * Binary data reception over UART" line15="     * @param value: none" line16="     * @return value: 16bit data If return value is 256, reception time out." line17="    */" line18="    function UART_BIN_RX(): number {" line19="        rxBuffer = serial.readBuffer(1)" line20="        if (rxBuffer.length &gt; 0) {" line21="            return rxBuffer[0]" line22="        }" line23="        return 0x100" line24="    }" line25="" line26="    function Send_Uart_data(dataArray: number[], length: number): void {" line27="        for (let i = 0; i &lt; length; i++) {" line28="            UART_BIN_TX(dataArray[i])" line29="            basic.pause(5)" line30="        }" line31="    }" line32="" line33="    function Receive_Uart_data(querySize: number): number[] {" line34="        let queryData = [0, 0, 0, 0, 0, 0, 0, 0]" line35="        let j = 0" line36="        while (j &lt; querySize) {" line37="            let rxData = UART_BIN_RX()" line38="            if (rxData &gt; 255) {" line39="                queryData[0] = 0" line40="                break" line41="            } else {" line42="                queryData[j] = rxData &amp; 0xff" line43="                j++" line44="            }" line45="        }" line46="        if (queryData[0] != 0) {" line47="            if (queryData[0] != 255 &amp;&amp; queryData[1] != 0) {" line48="                queryData[0] = 1" line49="            } else if (queryData[2] != querySize - 3) {" line50="                queryData[0] = 2" line51="            } else if (queryData[3] == 0xff) {" line52="                queryData[0] = 3" line53="            } else {" line54="                let checkSum = 0" line55="                for (let k = 0; k &lt; querySize - 1; k++) {" line56="                    checkSum += queryData[k]" line57="                }" line58="                if ((checkSum &amp; 255) != queryData[querySize - 1]) {" line59="                    queryData[0] = 4" line60="                }" line61="            }" line62="        }" line63="        return queryData" line64="    }" line65="" line66="    /**" line67="     * ZETag command execution" line68="     * @param txArray : number[]" line69="     * @param querySize: number" line70="     * @return queryData[]" line71="        queryData[0]:" line72="                0xff&#9;Query data is ready," line73="                   1    Time out error," line74="                   2&#9;Size error (Query size &lt;&gt; Receipt size)," line75="                   3    ZeTag error," line76="                   4    Checksum error," line77="                   5    Query data error" line78="       */" line79="    //% blockId=ZETag_command block=&quot;ZETag command %txArray %querySize&quot;" line80="    //% weight=80 blockGap=8" line81="    //% querySize.min=5 querySize.max=9 querySize.defl=5 " line82="    export function ZETag_command(txArray: number[], querySize: number): number[] {" line83="        const txArraySize = txArray.length" line84="        for (let l = 0; l &lt; txArraySize; l++) {" line85="            UART_BIN_TX(txArray[l])" line86="        }" line87="        let queryData2 = Receive_Uart_data(querySize)" line88="        if ((queryData2[3] != 0xf1) || (txArray[3] != 0xf0)) {" line89="            if (queryData2[3] != txArray[3]) {" line90="                queryData2[0] = 5" line91="            }" line92="        }" line93="        return queryData2" line94="    }" line95="" line96="    /**" line97="     * send zetag application data" line98="     */" line99="    //% blockId=Send_data block=&quot;Send ZETag data %dataArray&quot;" line100="    //% weight=80 blockGap=8" line101="    export function Send_data(dataArray: number[]): void {" line102="        // 0xff+2+0x80=0x181 -&gt; 0x81" line103="        // Query FF 00 02 80 81" line104="        let num = dataArray.length" line105="        if (num &lt; 1)    return;" line106="        if (num &gt; 30)   num = 30;" line107="        // 0xff+2+0x80=0x181 -&gt; 0x81  FF 00 02 80 xx xx xx" line108="        let checkSum2 = 0x81 + num" line109="        Send_Uart_data([0xff, 0x00, num + 2, 0x80], 4)" line110="        for (let m = 0; m &lt; num; m++) {" line111="            UART_BIN_TX(dataArray[m])" line112="            basic.pause(5)" line113="            checkSum2 += dataArray[m]" line114="        }" line115="        UART_BIN_TX(checkSum2 % 256)" line116="        let queryData3 = Receive_Uart_data(5)" line117="    }" line118="" line119="    /**" line120="     * set channel spacing" line121="     */" line122="    //% blockId=set_channel_spacing block=&quot;Set channel spacing %chSpace(KHz)&quot;" line123="    //% weight=80 blockGap=8" line124="    //% chSpace.min=100 chSpace.max=200 chSpace.defl=100" line125="    export function Set_channel_spacing(chSpace: number): void {" line126="        // FF 00 03 F0 64 56; 100KHz設定" line127="        // FF+00+03+F0=1F2 -&gt; 0xf2" line128="        // Query FF 00 02 F1 F2" line129="        if (chSpace &lt;= 100) {" line130="            chSpace = 100" line131="        } else if (chSpace &gt;= 200) {" line132="            chSpace = 200" line133="        }" line134="        Send_Uart_data([0xff, 0x00, 0x03, 0xf0, chSpace, (0xf2 + chSpace) % 256], 6)" line135="        let queryData4 = Receive_Uart_data(5)" line136="    }" line137="" line138="    /**" line139="     * set tx power" line140="     */" line141="    //% blockId=TX_Power block=&quot;TX Power %txPower (dB)&quot;" line142="    //% weight=80 blockGap=8" line143="    //% txPower.min=1 txPower.max=10 txPower.defl=10" line144="    export function Set_TX_Power(txPower: number): void {" line145="        if (txPower == 0) txPower = 1;" line146="        else if (txPower &gt;= 10) txPower = 10;" line147="" line148="        let txPowerData = txPower * 2" line149="        // FF 00 03 41 10 53; 出力8dB設定" line150="        // FF+00+03+41=0x143 -&gt; 0x43" line151="        // Query FF 00 02 41 42" line152="        Send_Uart_data([0xff, 0x00, 0x03, 0x41, txPowerData, (0x43 + txPowerData) % 256], 6)" line153="        let queryData5 = Receive_Uart_data(5)" line154="    }" line155="" line156="    /**" line157="     * set transmission frequency" line158="     */" line159="    //% blockId=Set_Frequency block=&quot;Set Frequency %frequency (Hz) %chNum (ch) %chStep&quot;" line160="    //% weight=80 blockGap=8" line161="    //% Frequency.min=470000000 Frequency.max=928000000 Frequency.defl=922080000" line162="    //% chNum.min=1 chNum.max=6 chNum.defl=2" line163="    //% chStep.min=1 chStep.max=2 chStep.defl=2" line164="    export function Set_Frequency(frequency: number, chNum: number, chStep: number): void {" line165="        // Query FF 00 02 40 41" line166="        let step = chStep" line167="        let channelCount = chNum &lt;= 1 ? 1 : chNum" line168="        channelCount = channelCount &gt; 6 ? 6 : channelCount" line169="" line170="        if (step == 0) step = 1;" line171="        else if (step &gt;= 2) step = 2;" line172="" line173="        let baseFrequency = frequency" line174="        if (baseFrequency &lt; 470000000) baseFrequency = 470000000;" line175="        else if (baseFrequency &gt; 928000000) baseFrequency = 928000000;" line176="        else if ((baseFrequency &gt; 510000000) &amp;&amp; (baseFrequency &lt; 920600000)) baseFrequency = 510000000;" line177="" line178="        let checkSum3 = 0" line179="        let paraArray = [" line180="            0xff, 0x00, 0x08 + channelCount, 0x40, 0x01," line181="            (baseFrequency &gt;&gt; 24) &amp; 0xff," line182="            (baseFrequency &gt;&gt; 16) &amp; 0xff," line183="            (baseFrequency &gt;&gt; 8) &amp; 0xff," line184="            baseFrequency &amp; 0xff," line185="            channelCount, 0, 0, 0, 0, 0, 0, 0" line186="        ]" line187="        if (channelCount &gt;= 2) {" line188="            for (let n = 0; n &lt; channelCount; n++) {" line189="                paraArray[10 + n] = n * step" line190="            }" line191="        } else {" line192="            paraArray[4] = 0" line193="        }" line194="        for (let o = 0; o &lt; channelCount + 10; o++) {" line195="            checkSum3 += paraArray[o]" line196="        }" line197="        checkSum3 %= 256" line198="        paraArray[10 + channelCount] = checkSum3" line199="        Send_Uart_data(paraArray, 11 + channelCount)" line200="        let queryData6 = Receive_Uart_data(5)" line201="    }" line202="}" numlines="203"></mutation></block></statement></block></xml>